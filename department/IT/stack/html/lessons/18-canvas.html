<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lesson 18: Canvas API Intro | Malone Global University</title>
  <meta name="description" content="Lesson 18 â€” Canvas API Intro: when to use &lt;canvas&gt; vs SVG, Canvas 2D drawing primitives and state, high-DPI scaling, animation with requestAnimationFrame, accessibility fallback patterns, and performance tips." />
  <link rel="icon" href="/image/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/component/css/main.css" />
  </head>

<body>

    <header class="navbar" role="navigation" aria-label="Main Navigation">
    <div class="logo-container">
      <a href="/index"><img src="/image/logo.png" alt="Malone University Logo" class="logo-img"></a>
      <span class="school-name"> Malone University</span>
    </div>

    <ul class="nav-links" id="nav-links">
      <li><a href="/contact">Contact</a></li>
      <li><a href="/about">About</a></li>
      <li><a href="/community/resources">Community</a></li>
      <li><a href="/homepage">Home</a></li>
      <li><a href="/mission">Mission</a></li>
      <li><a href="/library/directory">Library</a></li>
      <li><a href="/department/directory">Department</a></li>
      <li><a href="/devblog/live-journal">DevBlog</a></li>
     
    </ul>

    <div style="display:flex;align-items:center;">
      <div class="nav-toggle" id="nav-toggle" aria-label="Toggle menu" role="button" tabindex="0">
        <span></span><span></span><span></span>
      </div>

      <button id="theme-toggle" title="Toggle theme" aria-pressed="false">ðŸ’»</button>

    </div>
  </header>

 <main class="container">
   <!-- put generated lessons here -->

   <article class="lesson lesson-18">
     <h1>Lesson 18 â€” Canvas API Intro</h1>
     <p class="meta">Stage 3 â€” Advanced â†’ Lesson 18</p>

     <section>
       <h2>Overview</h2>
       <p>
         The HTML <code>&lt;canvas&gt;</code> element exposes a drawing surface you can control with JavaScript. It is a pixel-based bitmap â€” ideal for procedurally generated graphics, real-time animation, games, and visualizations where per-pixel control or high-performance raster rendering is required.
         This lesson explains when to choose <code>&lt;canvas&gt;</code> over SVG, covers the Canvas 2D API drawing primitives and state model, demonstrates high-DPI (retina) scaling, shows a basic animation loop using <code>requestAnimationFrame</code>, and outlines accessibility and performance best practices.
       </p>
     </section>

     <section>
       <h2>Canvas vs SVG â€” choose the right tool</h2>
       <p>
         Both Canvas and SVG render graphics, but they suit different use cases:
       </p>
       <ul>
         <li><strong>Use SVG</strong> when graphics are vector-based, need crisp scaling, interact with the DOM, or require accessible, semantic elements (icons, UI graphics, charts with selectable parts).</li>
         <li><strong>Use Canvas</strong> when you need pixel-level control, many objects (thousands of moving sprites), fast per-frame redraws (games, simulations), image processing, or procedural rendering that would be inefficient with many DOM nodes.</li>
         <li><strong>Hybrid</strong> approaches are common: use SVG/DOM for UI and overlays, and Canvas for the heavy, frequently redrawn visuals. Keep interactive controls outside the canvas for accessibility.</li>
       </ul>
     </section>

     <section>
       <h2>Canvas basics â€” element and 2D context</h2>
       <p>
         A Canvas element exposes drawing APIs via the rendering context. Most pages use the 2D context:
       </p>

<pre><code>&lt;canvas id="c" width="800" height="450" role="img" aria-label="Simple drawing example"&gt;
  Your browser does not support the canvas element.
&lt;/canvas&gt;

&lt;script&gt;
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d'); // 2D rendering context
&lt;/script&gt;
</code></pre>

       <p>
         Important: the <code>width</code> and <code>height</code> attributes set the internal pixel buffer size. CSS sizing only changes display size â€” to avoid blurring on high-DPI screens, you must scale the internal buffer to match device pixel ratio (covered below).
       </p>
     </section>

     <section>
       <h2>Drawing primitives â€” the essential API</h2>
       <p>
         The Canvas 2D API provides methods to draw shapes, text, images, and paths. Here are the common operations:
       </p>

       <h3>Rectangles</h3>
<pre><code>ctx.fillStyle = '#0a7';
ctx.fillRect(x, y, width, height);    // filled rectangle
ctx.clearRect(x, y, width, height);   // clear part of canvas (transparent)
ctx.strokeStyle = '#000';
ctx.strokeRect(x, y, width, height);  // stroked rectangle
</code></pre>

       <h3>Paths â€” lines, curves, arcs</h3>
<pre><code>ctx.beginPath();
ctx.moveTo(10, 10);
ctx.lineTo(100, 10);
ctx.lineTo(100, 100);
ctx.closePath();
ctx.stroke();

ctx.beginPath();
ctx.arc(cx, cy, radius, 0, Math.PI * 2); // circle
ctx.fill();
</code></pre>

       <h3>Curves</h3>
<pre><code>ctx.beginPath();
ctx.moveTo(10, 80);
ctx.quadraticCurveTo(50, 10, 90, 80); // quadratic
ctx.bezierCurveTo(20, 20, 80, 20, 90, 80); // cubic bezier
ctx.stroke();
</code></pre>

       <h3>Text & images</h3>
<pre><code>ctx.font = '16px system-ui';
ctx.fillStyle = '#222';
ctx.fillText('Hello Canvas', 20, 40);

const img = new Image();
img.onload = () =&gt; ctx.drawImage(img, 0, 0);
img.src = '/media/photo.jpg';
</code></pre>

       <h3>State, transforms, and compositing</h3>
<pre><code>ctx.save();               // push state
ctx.translate(50, 50);      // move origin
ctx.rotate(Math.PI / 6);    // rotate
ctx.scale(2, 2);            // scale
// draw...
ctx.restore();              // pop state

ctx.globalAlpha = 0.6;      // transparency
ctx.globalCompositeOperation = 'source-over'; // blend mode
</code></pre>

       <p>
         The drawing state (styles, transforms, clipping) is managed via <code>save()</code> and <code>restore()</code>, which lets you localize transformations and style changes.
       </p>
     </section>

     <section>
       <h2>High-DPI (retina) scaling</h2>
       <p>
         To render sharply on high-density displays, scale the canvas internal pixel buffer to the device pixel ratio (DPR):
       </p>

<pre><code>function resizeCanvasToDisplaySize(canvas) {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const width = Math.round(rect.width * dpr);
  const height = Math.round(rect.height * dpr);
  if (canvas.width !== width || canvas.height !== height) {
    canvas.width = width;
    canvas.height = height;
    // scale drawing operations to map CSS pixels -> device pixels
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return true;
  }
  return false;
}
</code></pre>

       <p>
         Set CSS width/height separately (via styles or attributes) to control layout, and set the internal pixel buffer (canvas.width/height) multiplied by DPR for crisp output. Use <code>ctx.setTransform</code> or <code>ctx.scale</code> so your drawing code can continue to work in CSS pixels.
       </p>
     </section>

     <section>
       <h2>Animation loop â€” requestAnimationFrame</h2>
       <p>
         Use <code>requestAnimationFrame</code> for smooth, efficient animations synchronized to the browser's refresh rate. Here's a minimal loop:
       </p>

<pre><code>let last = 0;
function render(ts) {
  const delta = ts - last;
  last = ts;
  // update state using delta
  // clear
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // draw frame
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</code></pre>

       <p>
         Use elapsed time (delta) to make animations framerate-independent. Avoid heavy per-frame allocations and unnecessary DOM reads/writes inside the animation loop.
       </p>
     </section>

     <section>
       <h2>Accessibility considerations</h2>
       <p>
         Canvas renders to a bitmap â€” by default its contents are not accessible. Follow these guidelines:
       </p>
       <ul>
         <li>Provide a meaningful <code>role</code> or <code>aria-label</code> on the canvas when it conveys information (e.g., <code>role="img" aria-label="Interactive scatter plot"</code>), and supply a text alternative nearby (caption, long description, or a semantic HTML fallback).</li>
         <li>Do not put essential controls or form inputs only inside the canvas unless you also provide a keyboard- and screen-reader-friendly DOM alternative or overlay controls outside the canvas.</li>
         <li>Include fallback content inside the <code>&lt;canvas&gt;</code> element for very old browsers; but primarily provide an HTML alternative (e.g., a table of data, transcript, or descriptive paragraph).</li>
         <li>Consider exposing the canvas drawing model as structured DOM (SVG or HTML) when interactivity must be accessible; otherwise keep interactive elements as separate DOM controls synchronized with the canvas visuals.</li>
       </ul>

<pre><code>&lt;canvas id="viz" role="img" aria-label="Enrollment by year chart"&gt;
  &lt;p&gt;This chart shows enrollment growth from 2018 to 2024. Visit the &lt;a href="/data/enrollment"&gt;data page&lt;/a&gt; for a table and accessibility-friendly view.&lt;/p&gt;
&lt;/canvas&gt;
</code></pre>
     </section>

     <section>
       <h2>Performance tips</h2>
       <ul>
         <li>Minimize draw calls per frame â€” batch drawing where possible.</li>
         <li>Reuse objects (avoid creating many temporary objects each frame).</li>
         <li>Use layered canvases: separate static background elements from dynamic foreground elements so you can redraw only what changes.</li>
         <li>Avoid expensive canvas operations (e.g., shadow blurs, large strokes) if they can be approximated with cheaper methods.</li>
         <li>Throttle or pause animations when the canvas is not visible (<code>document.hidden</code> or Visibility API).</li>
         <li>Prefer <code>clearRect</code> or a single <code>fillRect</code> to clear the frame rather than re-creating the canvas element.</li>
       </ul>
     </section>

     <section>
       <h2>Advanced notes (brief)</h2>
       <ul>
         <li><strong>OffscreenCanvas:</strong> allows rendering in a Web Worker for heavy workloads (check browser support) â€” useful for complex image processing or multi-threaded rendering.</li>
         <li><strong>WebGL:</strong> for GPU-accelerated 2D/3D rendering; use when you need shaders, 3D, or massive particle counts. WebGL has a steeper learning curve than Canvas 2D.</li>
         <li><strong>Hit testing:</strong> Canvas has no built-in DOM for elements â€” implement hit-testing manually (track shapes and test coordinates) or overlay transparent DOM elements for interaction.</li>
       </ul>
     </section>

     <section>
       <h2>Examples â€” simple drawing & animation</h2>

       <h3>Simple scene</h3>
<pre><code>const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// draw sky
ctx.fillStyle = '#87CEEB';
ctx.fillRect(0, 0, canvas.width, canvas.height);

// sun
ctx.beginPath();
ctx.arc(100, 80, 40, 0, Math.PI * 2);
ctx.fillStyle = '#FFD700';
ctx.fill();

// ground
ctx.fillStyle = '#2E8B57';
ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
</code></pre>

       <h3>Animated bouncing ball (concept)</h3>
<pre><code>let x = 50, y = 50, vx = 120, vy = 80; // pixels per second
let last = performance.now();

function frame(ts) {
  const dt = (ts - last) / 1000; // seconds
  last = ts;
  x += vx * dt;
  y += vy * dt;

  // bounce
  if (x &lt; 0 || x &gt; canvas.width) vx = -vx;
  if (y &lt; 0 || y &gt; canvas.height) vy = -vy;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.beginPath();
  ctx.arc(x, y, 20, 0, Math.PI * 2);
  ctx.fill();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</code></pre>
     </section>

     <section>
       <h2>Practice</h2>
       <ol>
         <li>Create <code>18-canvas-practice.html</code> and implement:
           <ul>
             <li>A simple static drawing (shapes, text, and an image).</li>
             <li>An animation using <code>requestAnimationFrame</code> (e.g., a bouncing ball or rotating sprite) that uses elapsed time to compute movement.</li>
             <li>High-DPI scaling: ensure the canvas looks sharp on retina displays by resizing the internal buffer and calling <code>ctx.setTransform</code> or <code>ctx.scale</code> â€” avoid drawing at CSS pixels without scaling.</li>
             <li>An accessibility fallback: a short textual description or a linked data table that conveys the same information as the canvas visualization.</li>
           </ul>
         </li>

         <li>Test and measure:
           <ul>
             <li>Resize the viewport and confirm the canvas resizes cleanly without blurring.</li>
             <li>Throttle CPU/network in DevTools to simulate low-power devices and ensure your animation remains performant or degrades gracefully.</li>
             <li>Use keyboard-only navigation to confirm that interactive controls (if any) are accessible outside the canvas area.</li>
           </ul>
         </li>

         <li>Optional advanced tasks:
           <ul>
             <li>Experiment with <code>OffscreenCanvas</code> in a Web Worker for an expensive rendering task (requires server/feature support).</li>
             <li>Try WebGL or a lightweight library for GPU-accelerated rendering if your use case demands it.</li>
           </ul>
         </li>
       </ol>
     </section>

     <section>
       <h2>Key Takeaways</h2>
       <ul>
         <li><strong>Canvas</strong> is a pixel-based drawing surface ideal for games, simulations, image processing, and high-frequency animation where DOM-based graphics would be inefficient.</li>
         <li><strong>SVG</strong> is preferable for vector graphics that need DOM access, styling, and accessible semantics; choose based on interactivity, scalability, and performance needs.</li>
         <li>Always handle high-DPI scaling by resizing the internal pixel buffer and scaling the drawing context for crisp results.</li>
         <li>Use <code>requestAnimationFrame</code> for animations, avoid per-frame allocations, and consider layered canvases to minimize redraw work.</li>
         <li>Canvas output is not inherently accessible â€” provide textual alternatives, keep interactive controls outside the canvas, and synchronize DOM overlays when necessary.</li>
       </ul>
     </section>

     <section>
       <h2>Next Steps</h2>
       <p>
         Proceed to <a href="19-html-apis.html">Lesson 19 â€” HTML APIs</a> to learn about browser APIs such as Geolocation, Drag-and-Drop, and Web Storage that often augment canvas-powered experiences.
       </p>
     </section>

   </article>

 </main>
  

  <footer>
    <p>Â© 2025 Malone University. Building the future, on our own terms.</p>
    <p>
      <a href="https://twitter.com/MaloneGlobal" target="_blank" rel="noopener noreferrer">Twitter</a> |
      <a href="https://facebook.com/YOUR_HANDLE" target="_blank" rel="noopener noreferrer">Facebook</a> |
      <a href="https://instagram.com/maloneglobaluniversity" target="_blank" rel="noopener noreferrer">Instagram</a> |
      <a href="/terms.html">Terms</a> |
      <a href="/contact.html">Contact</a>
    </p>


<p>Content updated: 8/20/2025<br>
   Layout updated: 8/20/2025</p>

  </footer>
   
<script src="/component/script/js/main.js"></script>
</body>
</html>

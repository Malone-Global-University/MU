Step 16: Performance Optimization
1. Lazy-Load Non-Critical Sections

Only render or load heavy content when it enters the viewport using the Intersection Observer API.

document.addEventListener("DOMContentLoaded", () => {
  const lazySections = document.querySelectorAll(".card[data-lazy]");

  const observer = new IntersectionObserver((entries, obs) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const section = entry.target;
        section.innerHTML = section.dataset.content; // Load content
        obs.unobserve(section);
      }
    });
  }, { rootMargin: "0px 0px 200px 0px" });

  lazySections.forEach(section => observer.observe(section));
});


HTML Example:

<section class="card" data-lazy data-content="<h2>Lazy Loaded</h2><p>This content loads when visible.</p>"></section>

2. Defer Non-Critical JavaScript

Use the defer attribute for external scripts so they donâ€™t block HTML parsing:

<script src="scripts.js" defer></script>


Inline critical JS (like theme toggle) can stay in <head> or at the top of <body> for instant UX feedback.

3. Minify CSS and JS

Use a build step (Webpack, Vite, or other bundlers) to:

Remove whitespace/comments

Combine multiple CSS/JS files

Apply gzip or Brotli compression on server

4. Optimize Rendering

Use will-change sparingly for animated elements to hint the browser about upcoming transformations:

.card {
  will-change: transform, box-shadow;
}


Keep CSS and JS modular to avoid blocking the main thread.

5. Prefetch Critical Resources

Preconnect to fonts, APIs, or external assets:

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="dns-prefetch" href="https://example.com">

6. Benefits of Step 16

Reduced Initial Load Time

Lazy loading and deferred JS improve Time to Interactive (TTI).

Efficient Resource Use

Only fetch and render content when needed.

Scalable UX

Even with dozens of dynamic cards or sections, the page remains responsive.

Future-Proofing

Supports larger layouts, dashboards, or interactive pages without performance degradation.

At this stage, your webpage is fully optimized, modular, interactive, responsive, accessible, and production-ready.